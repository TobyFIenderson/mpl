#pragma once
#ifndef __INCLUDE_COMMAND_H__
#define __INCLUDE_COMMAND_H__

#include "CalculatorManagerLibNS.h"
#include "AngleType.h"

CM_BEGIN

#define CMD_CODE inline constexpr int

CMD_CODE CMD_CODE_BEGIN = 0;

CMD_CODE NUM_BEGIN = CMD_CODE_BEGIN;
CMD_CODE NUM_0 = NUM_BEGIN;
CMD_CODE NUM_1 = NUM_0 + 1;
CMD_CODE NUM_2 = NUM_1 + 1;
CMD_CODE NUM_3 = NUM_2 + 1;
CMD_CODE NUM_4 = NUM_3 + 1;
CMD_CODE NUM_5 = NUM_4 + 1;
CMD_CODE NUM_6 = NUM_5 + 1;
CMD_CODE NUM_7 = NUM_6 + 1;
CMD_CODE NUM_8 = NUM_7 + 1;
CMD_CODE NUM_9 = NUM_8 + 1;
CMD_CODE NUM_A = NUM_9 + 1;
CMD_CODE NUM_B = NUM_A + 1;
CMD_CODE NUM_C = NUM_B + 1;
CMD_CODE NUM_D = NUM_C + 1;
CMD_CODE NUM_E = NUM_D + 1;
CMD_CODE NUM_F = NUM_E + 1;
CMD_CODE NUM_END = NUM_F;
CMD_CODE NUM_SIZE = NUM_END - NUM_BEGIN + 1;

CMD_CODE BIT_BEGIN = NUM_END + 1;
CMD_CODE BIT_00 = BIT_BEGIN;
CMD_CODE BIT_01 = BIT_00 + 1;
CMD_CODE BIT_02 = BIT_01 + 1;
CMD_CODE BIT_03 = BIT_02 + 1;
CMD_CODE BIT_04 = BIT_03 + 1;
CMD_CODE BIT_05 = BIT_04 + 1;
CMD_CODE BIT_06 = BIT_05 + 1;
CMD_CODE BIT_07 = BIT_06 + 1;
CMD_CODE BIT_08 = BIT_07 + 1;
CMD_CODE BIT_09 = BIT_08 + 1;
CMD_CODE BIT_10 = BIT_09 + 1;
CMD_CODE BIT_11 = BIT_10 + 1;
CMD_CODE BIT_12 = BIT_11 + 1;
CMD_CODE BIT_13 = BIT_12 + 1;
CMD_CODE BIT_14 = BIT_13 + 1;
CMD_CODE BIT_15 = BIT_14 + 1;
CMD_CODE BIT_16 = BIT_15 + 1;
CMD_CODE BIT_17 = BIT_16 + 1;
CMD_CODE BIT_18 = BIT_17 + 1;
CMD_CODE BIT_19 = BIT_18 + 1;
CMD_CODE BIT_20 = BIT_19 + 1;
CMD_CODE BIT_21 = BIT_20 + 1;
CMD_CODE BIT_22 = BIT_21 + 1;
CMD_CODE BIT_23 = BIT_22 + 1;
CMD_CODE BIT_24 = BIT_23 + 1;
CMD_CODE BIT_25 = BIT_24 + 1;
CMD_CODE BIT_26 = BIT_25 + 1;
CMD_CODE BIT_27 = BIT_26 + 1;
CMD_CODE BIT_28 = BIT_27 + 1;
CMD_CODE BIT_29 = BIT_28 + 1;
CMD_CODE BIT_30 = BIT_29 + 1;
CMD_CODE BIT_31 = BIT_30 + 1;
CMD_CODE BIT_32 = BIT_31 + 1;
CMD_CODE BIT_33 = BIT_32 + 1;
CMD_CODE BIT_34 = BIT_33 + 1;
CMD_CODE BIT_35 = BIT_34 + 1;
CMD_CODE BIT_36 = BIT_35 + 1;
CMD_CODE BIT_37 = BIT_36 + 1;
CMD_CODE BIT_38 = BIT_37 + 1;
CMD_CODE BIT_39 = BIT_38 + 1;
CMD_CODE BIT_40 = BIT_39 + 1;
CMD_CODE BIT_41 = BIT_40 + 1;
CMD_CODE BIT_42 = BIT_41 + 1;
CMD_CODE BIT_43 = BIT_42 + 1;
CMD_CODE BIT_44 = BIT_43 + 1;
CMD_CODE BIT_45 = BIT_44 + 1;
CMD_CODE BIT_46 = BIT_45 + 1;
CMD_CODE BIT_47 = BIT_46 + 1;
CMD_CODE BIT_48 = BIT_47 + 1;
CMD_CODE BIT_49 = BIT_48 + 1;
CMD_CODE BIT_50 = BIT_49 + 1;
CMD_CODE BIT_51 = BIT_50 + 1;
CMD_CODE BIT_52 = BIT_51 + 1;
CMD_CODE BIT_53 = BIT_52 + 1;
CMD_CODE BIT_54 = BIT_53 + 1;
CMD_CODE BIT_55 = BIT_54 + 1;
CMD_CODE BIT_56 = BIT_55 + 1;
CMD_CODE BIT_57 = BIT_56 + 1;
CMD_CODE BIT_58 = BIT_57 + 1;
CMD_CODE BIT_59 = BIT_58 + 1;
CMD_CODE BIT_60 = BIT_59 + 1;
CMD_CODE BIT_61 = BIT_60 + 1;
CMD_CODE BIT_62 = BIT_61 + 1;
CMD_CODE BIT_63 = BIT_62 + 1;
CMD_CODE BIT_END = BIT_63;
CMD_CODE BIT_SIZE = BIT_END - BIT_BEGIN + 1;

CMD_CODE BINARY_CMD_BEGIN = BIT_END + 1;
CMD_CODE ADD = BINARY_CMD_BEGIN;
CMD_CODE SUB = ADD + 1;
CMD_CODE MUL = SUB + 1;
CMD_CODE DIV = MUL + 1;
CMD_CODE REM = DIV + 1;
CMD_CODE MOD = REM + 1; // Programmer Mod
CMD_CODE LSHA = MOD + 1;
CMD_CODE LSHL = LSHA + 1;
CMD_CODE RSHA = LSHL + 1;
CMD_CODE RSHL = RSHA + 1;
CMD_CODE AND = RSHL + 1;
CMD_CODE OR = AND + 1;
CMD_CODE XOR = OR + 1;
CMD_CODE NAND = XOR + 1;
CMD_CODE NOR = NAND + 1;
CMD_CODE PWR = NOR + 1; // x^y
CMD_CODE YROOT = PWR + 1; // x^1/y
CMD_CODE LOGBASEY = YROOT + 1; // logy(x)
CMD_CODE BINARY_CMD_END = LOGBASEY;
CMD_CODE BINARY_CMD_SZIE = BINARY_CMD_END - BINARY_CMD_BEGIN + 1;

CMD_CODE UNARY_CMD_BEGIN = BINARY_CMD_END + 1;
CMD_CODE ROR = UNARY_CMD_BEGIN;
CMD_CODE ROL = ROR + 1;
CMD_CODE RORC = ROL + 1;
CMD_CODE ROLC = RORC + 1;
CMD_CODE NOT = ROLC + 1; // COM
CMD_CODE DMS = NOT + 1;
CMD_CODE DEGREE = DMS + 1;
CMD_CODE FRAC = DEGREE + 1;
CMD_CODE INT = FRAC + 1;
CMD_CODE SIN_DEG = INT + 1;
CMD_CODE SIN_RAD = SIN_DEG + 1;
CMD_CODE SIN_GRAD = SIN_RAD + 1;
CMD_CODE COS_DEG = SIN_GRAD + 1;
CMD_CODE COS_RAD = COS_DEG + 1;
CMD_CODE COS_GRAD = COS_RAD + 1;
CMD_CODE TAN_DEG = COS_GRAD + 1;
CMD_CODE TAN_RAD = TAN_DEG + 1;
CMD_CODE TAN_GRAD = TAN_RAD + 1;
CMD_CODE SINH = TAN_GRAD + 1;
CMD_CODE COSH = SINH + 1;
CMD_CODE TANH = COSH + 1;
CMD_CODE ARCSIN_DEG = TANH + 1;
CMD_CODE ARCSIN_RAD = ARCSIN_DEG + 1;
CMD_CODE ARCSIN_GRAD = ARCSIN_RAD + 1;
CMD_CODE ARCCOS_DEG = ARCSIN_GRAD + 1;
CMD_CODE ARCCOS_RAD = ARCCOS_DEG + 1;
CMD_CODE ARCCOS_GRAD = ARCCOS_RAD + 1;
CMD_CODE ARCTAN_DEG = ARCCOS_GRAD + 1;
CMD_CODE ARCTAN_RAD = ARCTAN_DEG + 1;
CMD_CODE ARCTAN_GRAD = ARCTAN_RAD + 1;
CMD_CODE ARSINH = ARCTAN_GRAD + 1;
CMD_CODE ARCOSH = ARSINH + 1;
CMD_CODE ARTANH = ARCOSH + 1;
CMD_CODE SEC_DEG = ARTANH + 1;
CMD_CODE SEC_RAD = SEC_DEG + 1;
CMD_CODE SEC_GRAD = SEC_RAD + 1;
CMD_CODE CSC_DEG = SEC_GRAD + 1;
CMD_CODE CSC_RAD = CSC_DEG + 1;
CMD_CODE CSC_GRAD = CSC_RAD + 1;
CMD_CODE COT_DEG = CSC_GRAD + 1;
CMD_CODE COT_RAD = COT_DEG + 1;
CMD_CODE COT_GRAD = COT_RAD + 1;
CMD_CODE SECH = COT_GRAD + 1;
CMD_CODE CSCH = SECH + 1;
CMD_CODE COTH = CSCH + 1;
CMD_CODE ARCSEC_DEG = COTH + 1;
CMD_CODE ARCSEC_RAD = ARCSEC_DEG + 1;
CMD_CODE ARCSEC_GRAD = ARCSEC_RAD + 1;
CMD_CODE ARCCSC_DEG = ARCSEC_GRAD + 1;
CMD_CODE ARCCSC_RAD = ARCCSC_DEG + 1;
CMD_CODE ARCCSC_GRAD = ARCCSC_RAD + 1;
CMD_CODE ARCCOT_DEG = ARCCSC_GRAD + 1;
CMD_CODE ARCCOT_RAD = ARCCOT_DEG + 1;
CMD_CODE ARCCOT_GRAD = ARCCOT_RAD + 1;
CMD_CODE ARSECH = ARCCOT_GRAD + 1;
CMD_CODE ARCSCH = ARSECH + 1;
CMD_CODE ARCOTH = ARCSCH + 1;
CMD_CODE LN = ARCOTH + 1;
CMD_CODE LOG = LN + 1;
CMD_CODE INV = LOG + 1;
CMD_CODE SQU = INV + 1;
CMD_CODE SQRT = SQU + 1;
CMD_CODE CUB = SQRT + 1;
CMD_CODE CUBT = CUB + 1;
CMD_CODE PWR10 = CUBT + 1; // 10^x
CMD_CODE PWR2 = PWR10 + 1; // 2^x
CMD_CODE PWRE = PWR2 + 1; // e^x
CMD_CODE PERCENT = PWRE + 1;
CMD_CODE ABS = PERCENT + 1;
CMD_CODE FLOOR = ABS + 1;
CMD_CODE CEIL = FLOOR + 1;
CMD_CODE NEG = CEIL + 1;
CMD_CODE UNARY_CMD_END = NEG;
CMD_CODE UNARY_CMD_SZIE = UNARY_CMD_END - UNARY_CMD_BEGIN + 1;

CMD_CODE GUI_CMD_BEGIN = UNARY_CMD_END + 1;
CMD_CODE EXP = GUI_CMD_BEGIN + 1;
CMD_CODE LSH = EXP + 1; // SH Shift L Left
CMD_CODE RSH = LSH + 1; // R Right
CMD_CODE SHA = RSH + 1; // 算术移位 A Arithmetic
CMD_CODE SHL = SHA + 1; // 逻辑移位 L Logic
CMD_CODE ROSH = SHL + 1; // 循环移位 RO Rotate
CMD_CODE RCSH = ROSH + 1; // 通过循环移位旋转 RC Rotate Circular
CMD_CODE CLEAR = RCSH + 1;
CMD_CODE CENTR = CLEAR + 1; // Clear Enter
CMD_CODE BACK = CENTR + 1;
CMD_CODE OPENP = BACK + 1; // (
CMD_CODE CLOSEP = OPENP + 1; // )
CMD_CODE EQU = CLOSEP + 1;
CMD_CODE PNT = EQU + 1;
CMD_CODE SIGN = PNT + 1;
CMD_CODE MSTORE = SIGN + 1;  // mem_value = current_value;
CMD_CODE MRECALL = MSTORE + 1;
CMD_CODE MPLUS = MRECALL + 1;
CMD_CODE MMINUS = MPLUS + 1;
CMD_CODE MCLEAR = MMINUS + 1;
CMD_CODE BIN = MCLEAR + 1;
CMD_CODE OCT = BIN + 1;
CMD_CODE DEC = OCT + 1;
CMD_CODE HEX = DEC + 1;
CMD_CODE BYTE = HEX + 1;
CMD_CODE WORD = BYTE + 1;
CMD_CODE DWORD = WORD + 1;
CMD_CODE QWORD = DWORD + 1;
CMD_CODE DEG = QWORD + 1;
CMD_CODE RAD = DEG + 1;
CMD_CODE GRAD = RAD + 1;
CMD_CODE FLOFMT = GRAD + 1;		// Standered Format
CMD_CODE SCIFMT = FLOFMT + 1;	// Scientific Format
CMD_CODE ENGFMT = SCIFMT + 1;	// Engineer Format
CMD_CODE STDMODE = ENGFMT + 1;	// Standered Mode
CMD_CODE SCIMODE = STDMODE + 1;	// Scitific Mode
CMD_CODE PROMODE = SCIMODE + 1;	// Programmer Mode
CMD_CODE INVC = PROMODE + 1;
CMD_CODE HYP = INVC + 1;
CMD_CODE SIN = HYP + 1;
CMD_CODE COS = SIN + 1;
CMD_CODE TAN = COS + 1;
CMD_CODE SEC = TAN + 1;
CMD_CODE CSC = SEC + 1;
CMD_CODE COT = CSC + 1;
CMD_CODE PI = COT + 1;
CMD_CODE EULER = PI + 1;
CMD_CODE RAND = EULER + 1;
CMD_CODE SET_RET = RAND + 1; // SET RESULT
CMD_CODE GUI_CMD_END = SET_RET;
CMD_CODE GUI_CMD_SIZE = GUI_CMD_END - GUI_CMD_BEGIN + 1;

CMD_CODE CMD_NULL = GUI_CMD_END + 1;
CMD_CODE CMD_CODE_END = CMD_NULL;
CMD_CODE CMD_CODE_SIZE = CMD_CODE_END - CMD_CODE_BEGIN + 1;

#undef CMD_CODE

using Command = int;
/*-----------------------------------------------------------*\
* CommandType 比较混乱，
* ExpressionCommand 使用的是 Unary Binary Operand Parentheses
* GetCommandTypeFromCommand 使用的是除 Parentheses 之外的全部
\*------------------------------------------------------------*/
enum class CommandType
{
	Unary = 0,
	Binary = 1,
	Operand = 2,
	Parentheses = 3,
	BitPosition = 4,
	NumberDigit = 5,
	GUISetting = 6,
	Null = 7
};

enum class ShiftType
{
	Arthmetic = 0,
	Logic = 1,
	Rotate = 2,
	RotateCircle = 3,
	Null = 4
};

enum class TrigonometricFunction
{
	Sine = 0,
	Cosine = 1,
	Tangent = 2,
	Secant = 3,
	Cosecant = 4,
	Cotangent = 5,
	Null = 6
};

CommandType GetCommandType(Command cmd);
Command GetShiftCommand(ShiftType shift_type, Command shift_direction);
Command GetTrigonometricFunctionCommand(TrigonometricFunction tf, AngleType angle_type, bool inv, bool hyp);
Command GetInvertCommand(Command cmd);
int GetBinaryCommandPrecedence(Command cmd);

// 比较两二元运算符的优先级
// 大于零表示前一个运算符的优先级大于后一个
// 小于零表示前一个运算符的优先级小于后一个
// 等于零表示前一个运算符的优先级等于后一个
int CompareBinaryCommandPrecedence(Command cmd1, Command cmd2);

#define INRANGE(x,sma,lag) ((x)>=(sma)&&(x)<=(lag))

CM_END
#endif // !__INCLUDE_CALCULATOR_COMMAND_H__
