#include "mpf.h"
MPL_BEGIN
static constexpr uint32_t MIN_SPLIT = 32;
static int32_t prec = MPF_ORIGINAL_PRECISION;
static const mpf::init_struct mpf_constant_e_init_struct =
{
	-129,
	{
		1,
		130,
		{
			109538648, 254684648, 174483660, 67166244, 238967915, 51492637, 44326988, 178527616,
			191339020, 94926852, 218915515, 119675838, 52337741, 244709575, 19004758, 89394432,
			232321991, 176010337, 257413301, 22993585, 175716706, 65922243, 12948349, 96058699,
			161974204, 126907565, 90660617, 209959167, 125554438, 28305743, 58896180, 190255393,
			124774032, 204974952, 21521894, 149436079, 183584909, 175874484, 182921085, 225622538,
			209539839, 63670393, 97744089, 85019531, 240205119, 38727949, 204276931, 101994057,
			197100738, 102458482, 53231280, 266320230, 122266749, 69069668, 41269682, 25612735,
			241631374, 13882235, 104912623, 91024788, 66533261, 148997247, 245504720, 184994751,
			29151881, 73010891, 62677215, 142612246, 254741424, 97316567, 114498539, 252705004,
			196911200, 154945739, 23134179, 200962982, 198730844, 53780688, 187698433, 121102219,
			125878072, 136951234, 32109115, 183264300, 192534748, 131250523, 150441555, 7683338,
			137755930, 95120093, 37289710, 44379851, 249066562, 101371027, 246350508, 220260837,
			204157587, 179805396, 206973005, 262260855, 41336059, 232753818, 205011362, 107035697,
			265679437, 89935225, 189185261, 227890423, 196354392, 75332633, 139005181, 123205013,
			83347381, 185697771, 7110827, 30893018, 148428995, 199619775, 59320015, 254955127,
			85527806, 126146820, 189637994, 118886200, 255620654, 142646516, 111933205, 42659114,
			192812310, 2,
		}
	}
};
static mpf e = mpf_constant_e_init_struct;

/* 返回计算 d 位有效数字所需的最大的 n */
static uint32_t maxn(uint32_t d)
{
	double f = d * log(10);
	double r = 0;
	uint32_t i = 0;
	do
	{
		i++;
		r += log(i);
	} while (r < f);
	return i;
}

static void split_euler(uint32_t n, uint32_t m, mpf& p, mpf& q)
{
	if (m - n <= MIN_SPLIT)
	{/* 当 n 和 m 相差很小时直接计算 */
		p.set_d(1);
		q.set_d(1);
		for (uint32_t i = m; i > n; i--)
		{
			mpf::mul_d(q, i, q);
			mpf::add(p, q, p);
		}
		mpf::mul_d(q, n, q);
		return;
	}
	mpf p1, p2, q1, q2;
	split_euler(n, (n + m) >> 1, p1, q1);
	split_euler((n + m + 2) >> 1, m, p2, q2);
	mpf::mul(p1, q2, p);
	mpf::add(p, p2, p);
	mpf::mul(q1, q2, q);
}

mpf const& mpf::const_e()
{
	if (MPF_ORIGINAL_PRECISION <= prec)
	{
		return e;
	}
	mpf p, q;
	double r = log(MPI_BASE) / log(10);
	uint32_t n = maxn(uint32_t(MPF_PRECISION * r));
	split_euler(1, n, p, q);
	mpf::add(p, q, p);
	mpf::div(p, q, p);
	e.swap(p);
	prec = MPF_ORIGINAL_PRECISION;
	return e;
}
MPL_END